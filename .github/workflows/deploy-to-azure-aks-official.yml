# This workflow demonstrates building a container image, pushing to an Azure Container Registry and deploying to Kubernetes
# It is split into separate jobs for readability but could be squashed into a single job if that best suits your scenario
# Official doc link - https://github.com/Azure/aks-baseline-automation/blob/main/.github/workflows/App-Flask-DockerBuild.yml

name: Deploy to Azure AKS (Official Method)

on:
  workflow_dispatch:
    inputs:
      RG:
        description: 'The Resource Group where your resources are deployed'
        required: true
        default: "saquib-test"
        type: string
      AKSNAME:
        description: 'The Name of the AKS resource'
        required: true
        default: "test-cluster"
        type: string
      ACRNAME:
        description: 'The Name of the ACR resource'
        required: true
        default: "sqbregistry"
        type: string
      APPNAME:
        description: 'The Name of the Application to deploy'
        default: "frontend"
        required: true
        type: string
      NAMESPACE:
        description: 'The Kubernetes Namespace to deploy the Application to'
        default: "playground"
        required: false
        type: string
      ENVIRONMENT:
        description: 'A GitHub Environment to pull action secrets from'
        default: "azure-aks"
        required: true
        type: environment

permissions:
      id-token: write
      contents: read

jobs:
  Build-and-Push:
    runs-on: ubuntu-latest
    environment: ${{ inputs.ENVIRONMENT }}
    env:
      ACRNAME: "${{ inputs.ACRNAME}}"

    steps:
      - name: Get application code from repo
        uses: actions/checkout@v5

      - name: Job parameter inspection
        run: |
          echo "Resource Group is ${{ inputs.RG }}"
          echo "AKS name is ${{ inputs.AKSNAME }}"
          echo "ACR name is ${{ inputs.ACRNAME }}"
          echo "Application name is ${{ inputs.APPNAME }}"
          echo "Namespace is ${{ inputs.NAMESPACE }}"
          echo "Environment is ${{ inputs.ENVIRONMENT }}"

      - name: Azure Login
        uses: Azure/login@v2
        with:
          creds: ${{ secrets.AZURE_SERVICE_PRINCIPAL_CREDENTIALS_JSON }}

      # - name: Connect to ACR (Official Method)
      #   id: acrconnect
      #   run: |
      #     echo "Retrieving access token from $ACRNAME"
      #     TOKEN=$(az acr login -n $ACRNAME --expose-token)

      #     if [ -z "$TOKEN" ]
      #     then
      #       echo "ACR Token was not retrieved successfully"
      #       exit 1
      #     fi

      #     ACRTOKEN=$(echo $TOKEN | jq -r ".accessToken")
      #     LOGINSERVER=$(echo $TOKEN | jq -r ".loginServer")

      #     echo "ACR Login Server: $LOGINSERVER"
      #     echo "::set-output name=loginServer::$LOGINSERVER"

      #     echo "Passing token as stdin to docker login"
      #     echo $ACRTOKEN | docker login $LOGINSERVER -u 00000000-0000-0000-0000-000000000000 --password-stdin

      - name: Docker Login to ACR (My Custom Method)
        uses: azure/docker-login@v2
        # you can use the registry name as username and admin user access key as password to docker login to your container registry.
        with:
          login-server: ${{ inputs.ACRNAME }}.azurecr.io
          username: ${{ inputs.ACRNAME }}
          password: ${{ secrets.ACR_PASSWORD }}  

      - name: Build and Push Image to ACR
        env:
          ACRSERVER: "${{ inputs.ACRNAME }}.azurecr.io"   # commenting as using my custom method "${{ steps.acrconnect.outputs.loginServer }}"
          APPNAME: "${{ inputs.APPNAME }}"
        run: |
          docker build -t $ACRSERVER/$APPNAME:${{ github.sha }} -t $ACRSERVER/$APPNAME:latest -f Dockerfile .
          docker push $ACRSERVER/$APPNAME:${{ github.sha }}
          docker push $ACRSERVER/$APPNAME:latest
          echo "appimage=$ACRSERVER/$APPNAME:${{ github.sha }}" >> $GITHUB_OUTPUT

  Deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.ENVIRONMENT }}
    needs: [Build-and-Push]

    steps:
      - name: Get application k8s manifests from repo
        uses: actions/checkout@v5

      - name: Azure Login
        uses: Azure/login@v2
        with:
          creds: ${{ secrets.AZURE_SERVICE_PRINCIPAL_CREDENTIALS_JSON }}

      - name: Install Kubectl
        uses: azure/setup-kubectl@v3.0
        with:
            version: 'latest'

      - name: Set the target AKS cluster
        uses: azure/aks-set-context@v2.0
        with:
          cluster-name: ${{ inputs.AKSNAME }}
          resource-group: ${{ inputs.RG }}

      - name: Kubelogin
        env:
          kubeloginversion: 'v0.0.11'
        run: |
          wget https://github.com/Azure/kubelogin/releases/download/${{ env.kubeloginversion }}/kubelogin-linux-amd64.zip
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/bin
          kubelogin convert-kubeconfig -l azurecli

      - name: Create the namespace if it does not exist
        if: ${{ inputs.NAMESPACE }} != 'default'
        run: |
          cmdOut=$(kubectl get namespaces ${{ inputs.NAMESPACE }} -o json | jq -r '.status.phase')
          if [ "$cmdOut" != 'Active' ]; then kubectl create namespace ${{ inputs.NAMESPACE }}; fi

      - name: Deploy app to AKS
        uses: azure/k8s-deploy@v1.5
        env:
          ACRNAME: "${{ inputs.ACRNAME}}"
        with:
          manifests: |
           azure-aks-manifests/deployment.yaml
           azure-aks-manifests/ingress.yaml
          images: |
            ${{ env.ACRNAME }}.azurecr.io/${{ inputs.APPNAME }}:${{ github.sha }}
          namespace: ${{ inputs.NAMESPACE }}
          strategy: blue-green # Acceptable values: basic/canary/blue-green, default is basic

      ######## CUSTOM STEPS FOR DEPLOYMENT #############    
      # - name: Replace Image in Deployment YAML
      #   run: |
      #     echo "Replacing image in deployment.yml - ${{ inputs.ACRNAME }}.azurecr.io/${{ inputs.APPNAME }}:${{ github.sha }}"
      #     sed -i "s|FE_IMAGE_PLACEHOLDER|${{ inputs.ACRNAME }}.azurecr.io/${{ inputs.APPNAME }}:${{ github.sha }}|g" azure-aks-manifests/deployment.yml

      # - name: Pre Check
      #   run: |
      #     # See what would be applied without actually doing it
      #     echo "DRY RUN"
      #     kubectl apply -f azure-aks-manifests/ -R --dry-run=client

      #     # Or use diff to see changes
      #     echo "DIFF CHECK"
      #     kubectl diff -f azure-aks-manifests/ -R || true

      # - name: Release Resources to AKS
      #   run: |
      #     kubectl apply -f azure-aks-manifests/ -R
      #     kubectl rollout status deployment/${{ inputs.APPNAME }}-deployment -n ${{ inputs.NAMESPACE }} --timeout=180s

      - name: List Everything
        run: |
          sleep 10
          kubectl get all -n ${{ inputs.NAMESPACE }}
  